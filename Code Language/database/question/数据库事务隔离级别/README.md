----------------------------------------------
> *Made By Herolh*
----------------------------------------------

# 数据库事务隔离级别 {#index}

[TOC]



 







--------------------------------------------

## 文档版本

|    时间    | 修改人 | 内容     |
| :--------: | :----: | :------- |
| 2021–08-03 | Herolh | 文档创建 |
|            |        |          |



## 简介

> [CSDN - jim_cainiaoxiaolang - 数据库事务隔离级别](https://blog.csdn.net/jim_cainiaoxiaolang/article/details/72832217)

&emsp;&emsp;**事务隔离（isolation）**定义了数据库系统中一个操作产生的影响什么时候以哪种方式可以对其他并发操作可见。隔离是事务 ACID (原子性、一致性性、隔离性、持久性) 四大属性中的一个重要属性。





## 并发控制 (Concurrency control)
&emsp;&emsp;并发控制描述了数据库处理隔离以保证数据正确性的机制。为了保证并行事务执行的准确执行数据库和存储引擎在设计的时候着重强调了这一点。典型的事务相关机制限制数据的访问顺序 (执行调度) 以满足可序列化和可恢复性。限制数据访问意味着降低了执行的性能，并发控制机制就是要保证在满足这些限制的前提下提供尽可能高的性能。经常在不损害正确性的情况下，为了达到更好的性能，可序列化的的要求会减低一些，但是为了避免数据一致性的破坏，可恢复性必须保证。
&emsp;&emsp;两阶段锁是关系数据库中最常见的提供了可序列化和可恢复性的并发控制机制，为了访问一个数据库对象，事务首先要获得这个对象的锁。对于不同的访问类型（如对对象的读写操作）和锁的类型，如果另外一个事务正持有这个对象的锁，获得锁的过程会被阻塞或者延迟。



## 隔离级别 (Isolation levels)

&emsp;&emsp;在数据库事务的 ACID 四个属性中，隔离性是一个最常放松的一个。为了获取更高的隔离等级，数据库系统的锁机制或者多版本并发控制机制都会影响并发。 应用软件也需要额外的逻辑来使其正常工作。
&emsp;&emsp;很多 DBMS 定义了不同的 “事务隔离等级” 来控制锁的程度。在很多数据库系统中，多数的数据库事务都避免高等级的隔离等级（如可序列化）从而减少对系统的锁定开销。程序员需要小心的分析数据库访问部分的代码来保证隔离级别的降低不会造成难以发现的代码 bug。相反的，==更高的隔离级别会增加死锁发生的几率，同样需要编程过程中去避免==。
ANSI/ISO SQL 定义的标准隔离级别如下:



### 可序列化 (Serializable)

&emsp;&emsp;**最高的隔离级别**。
&emsp;&emsp;在基于锁机制并发控制的 DBMS 实现可序列化要求在选定对象上的读锁和写锁保持直到事务结束后才能释放。在 SELECT 的查询中使用一个 “WHERE” 子句来描述一个范围时应该获得一个 “范围锁 (range-locks)”。这种机制可以避免 “幻影读 (phantom reads)” 现象。
&emsp;&emsp;当采用不基于锁的并发控制时不用获取锁。但当系统探测到几个并发事务有 “写冲突” 的时候，只有其中一个是允许提交的。这种机制的详细描述见 “' 快照隔离”



### 可重复读 (Repeatable reads)

&emsp;&emsp;在可重复读 (REPEATABLE READS) 隔离级别中，基于锁机制并发控制的 DBMS 需要对选定对象的读锁 (read locks) 和写锁 (write locks) 一直保持到事务结束，但不要求 “范围锁 (range-locks)”，因此可能会发生 “幻影读 (phantom reads)”



### 提交读 (Read committed)

&emsp;&emsp;在提交读 (READ COMMITTED) 级别中，基于锁机制并发控制的 DBMS 需要对选定对象的写锁 (write locks) 一直保持到事务结束，但是读锁 (read locks) 在 SELECT 操作完成后马上释放（因此 “不可重复读” 现象可能会发生，见下面描述）。和前一种隔离级别一样，也不要求 “范围锁 (range-locks)”。
&emsp;&emsp;简而言之，提交读这种隔离级别保证了读到的任何数据都是提交的数据，避免读到中间的未提交的数据，***脏读 (dirty reads)***。但是不保证事务重新读的时候能读到相同的数据，因为在每次数据读完之后其他事务可以修改刚才读到的数据。



### 未提交读 (Read uncommitted)

&emsp;&emsp;未提交读 (READ UNCOMMITTED) 是最低的隔离级别。允许***脏读 (dirty reads)***，事务可以看到其他事务 “尚未提交” 的修改。
&emsp;&emsp;通过比低一级的隔离级别要求更多的限制，高一级的级别提供更强的隔离性。标准允许事务运行在更强的事务隔离级别上。(如在可重复读 (REPEATABLE READS) 隔离级别上执行提交读 (READ COMMITTED) 的事务是没有问题的)





## 默认隔离级别

&emsp;&emsp;不同的 DBMS 默认隔离级别也不同。多少数据库允许用户设置隔离级别。有些 DBMS 在执行一个 SELECT 语句时使用额外的语法来获取锁 (如 *SELECT ... FOR UPDATE* 来获得在访问的数据行上的排他锁)



## 读现象 (Read phenomena)

ANSI/ISO 标准 SQL 92 涉及三种不同的一个事务读取另外一个事务可能修改的数据的 “读现象”。

下面的例子中，两个事务，事务 1 执行语句 1。接着，事务 2 执行语句 2 并且提交，最后事务 1 再执行语句 1. 查询使用如下的数据表。

|  id  | name | age  |
| :--: | :--: | :--: |
|  1   | Joe  |  20  |
|  2   | Jill |  25  |



### 脏读 

> Dirty reads (Uncommitted Dependency)

当一个事务允许读取另外一个事务修改但未提交的数据时，就可能发生脏读 (dirty reads)。

&emsp;&emsp;脏读 (dirty reads) 和不可重复读 (non-repeatable reads) 类似。事务 2 没有提交造成事务 1 的语句 1 两次执行得到不同的结果集。在未提交读 (READ UNCOMMITTED) 隔离级别唯一禁止的是更新混乱，即早期的更新可能出现在后来更新之前的结果集中。
&emsp;&emsp;在我们的例子中，事务 2 修改了一行，但是没有提交，事务 1 读了这个没有提交的数据。现在如果事务 2 回滚了刚才的修改或者做了另外的修改的话，事务 1 中查到的数据就是不正确的了。

| 事务 1                                                       | 事务 2                                                       |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| `/* Query 1 */ `<br />`SELECT age FROM users WHERE id = 1; `<br />`/* will read 20 */ ` |                                                              |
|                                                              | `/* Query 2 */ `<br />`UPDATE users SET age = 21 WHERE id = 1; `<br />`/* No commit here */ ` |
| `/* Query 1 */ `<br />`SELECT age FROM users WHERE id = 1; `<br />`/* will read 21 */ ` |                                                              |
|                                                              | `ROLLBACK; `<br />`/* lock-based DIRTY READ */ `             |

在这个例子中，事务 2 回滚后就没有 id 是 1，age 是 21 的数据行了。



### 不可重复读 

>  non-repeatable read

&emsp;&emsp;在一次事务中，当一行数据获取两遍得到不同的结果表示发生了 “不可重复读 (non-repeatable read)”.
&emsp;&emsp;在基于锁的并发控制中 “不可重复读 (non-repeatable read)” 现象发生在当执行 SELECT 操作时没有获得读锁 (read locks) 或者 SELECT 操作执行完后马上释放了读锁； 多版本并发控制中当没有要求一个提交冲突的事务回滚也会发生 “不可重复读 (non-repeatable read)” 现象。

| 事务 1                                                       | 事务 2                                                       |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| `/* Query 1 */ `<br />`SELECT * FROM users WHERE id = 1; `   |                                                              |
|                                                              | `/* Query 2 */ `<br />`UPDATE users SET age = 21 WHERE id = 1; COMMIT; `<br />`/* in multiversion concurrency   control, or lock-based READ COMMITTED */ ` |
| `/* Query 1 */ `<br />`SELECT * FROM users WHERE id = 1; COMMIT; `<br />`/* lock-based REPEATABLE READ */ ` |                                                              |

&emsp;&emsp;在这个例子中，事务 2 提交成功，因此他对 id 为 1 的行的修改就对其他事务可见了。但是事务 1 在此前已经从这行读到了另外一个 “age” 的值。在可序列化 (SERIALIZABLE) 和可重复读 (REPEATABLE READS) 的隔离级别，数据库在第二次 SELECT 请求的时候应该返回事务 2 更新之前的值。在提交读 (READ COMMITTED) 和未提交读 (READ UNCOMMITTED)，返回的是更新之后的值，这个现象就是不可重复读 (non-repeatable read)。

&emsp;&emsp;有两种策略可以避免不可重复读 (non-repeatable read)。一个是要求事务 2 延迟到事务 1 提交或者回滚之后再执行。这种方式实现了 **T1, T2** 的串行化 调度。串行化调度可以支持可重复读 (repeatable reads)。
&emsp;&emsp;另一种策略是*多版本并发控制*。为了得到更好的并发性能，允许事务 2 先提交。但因为事务 1 在事务 2 之前开始，事务 1 必须在其开始执行时间点的数据库的快照上面操作。当事务 1 最终提交时候，数据库会检查其结果是否等价于 **T1, T2** 串行调度。如果等价，则允许事务 1 提交，如果不等价，事务 1 需要回滚并抛出个串行化失败的错误。
&emsp;&emsp;使用基于锁的并发控制，在可重复读 (REPEATABLE READS) 的隔离级别中，ID=1 的行会被锁住，在事务 1 提交或回滚前一直阻塞语句 2 的执行。在提交读 (READ COMMITTED) 的级别，语句 1 第二次执行，age 已经被修改了。
&emsp;&emsp;在*多版本并发控制*机制下，可序列化 (SERIALIZABLE) 级别，两次 SELECT 语句读到的数据都是事务 1 开始的快照，因此返回同样的数据。但是，如果事务 1 试图 UPDATE 这行数据，事务 1 会被要求回滚并抛出一个串行化失败的错误。
&emsp;&emsp;在提交读 (READ COMMITTED) 隔离级别，每个语句读到的是语句执行前的快照，因此读到更新前后不同的值。在这种级别不会有串行化的错误 (因为这种级别不要求串行化)，事务 1 也不要求重试。



### 幻影读 

> phantom read

在事务执行过程中，当两个完全相同的查询语句执行得到不同的结果集。这种现象称为 “幻影读”

当事务没有获取*范围锁*的情况下执行 *SELECT ... WHERE* 操作可能会发生 “幻影读”。
==“幻影读” 是*不可重复读* 的一种特殊场景==：当事务 1 两次执行 *SELECT ... WHERE* 检索一定范围内数据的操作中间，事务 2 在这个表中创建了 (如 INSERT) 了一行新数据，这条新数据正好满足事务 1 的 “WHERE” 子句。

| 事务 1                                                       | 事务 2                                                       |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| `/* Query 1 */ `<br />`SELECT * FROM users WHERE age BETWEEN 10 AND 30; ` |                                                              |
|                                                              | `/* Query 2 */ `<br />`INSERT INTO users VALUES ( 3, 'Bob', 27 ); COMMIT; ` |
| `/* Query 1 */ `<br />`SELECT * FROM users WHERE age BETWEEN 10 AND 30; ` |                                                              |

&emsp;&emsp;需要指出的是事务 1 执行了两遍同样的查询语句。如果设了最高的隔离级别，两次会得到同样的结果集，这也正是数据库在可序列化 (SERIALIZABLE) 隔离级别上需要满足的。但是在较低的隔离级别上，第二次查询可能会得到不同的结果集。
&emsp;&emsp;在可序列化 (SERIALIZABLE) 隔离级别，查询语句 1 在 age 从 10 到 30 的记录上加锁，事务 2 只能阻塞直至事务 1 提交。在可重复读 (REPEATABLE READ) 级别，这个范围不会被锁定，允许记录插入，因此第二次执行语句 1 的结果中会包括新插入的行。



## 隔离级别、读现象和锁 

### 隔离级别 vs 读现象 

> Isolation Levels vs Read Phenomena

| 隔离级别 |   脏读   | 不可重复读 |  幻影读  |
| :------: | :------: | :--------: | :------: |
| 未提交读 | 可能发生 |  可能发生  | 可能发生 |
|  提交读  |    -     |  可能发生  | 可能发生 |
| 可重复读 |    -     |     -      | 可能发生 |
| 可序列化 |    -     |     -      |    -     |

可序列化 (Serializable) 隔离级别不等同于可串行化。可串行化调度 (Serializable) 是避免以上三种现象的必要条件，但不是充分条件。

“可能发生” 表示这个隔离级别会发生对应的现象，“-” 表示不会发生。



### 隔离级别 vs 锁持续时间 

> Isolation Levels vs Lock Duration

在基于锁的并发控制中，隔离级别决定了锁的持有时间。**"C"**- 表示锁会持续到事务提交。 **"S"** –表示锁持续到当前语句执行完毕。如果锁在语句执行完毕就释放则另外一个事务就可以在这个事务提交前修改锁定的数据，从而造成混乱。

| 隔离级别 l | 写操作 | 读操作 | 范围操作 (...where...) |
| :--------: | :----: | :----: | :--------------------: |
|  未提交读  |   S    |   S    |           S            |
|   提交读   |   C    |   S    |           S            |
|  可重复读  |   C    |   C    |           S            |
|  可序列化  |   C    |   C    |           C            |

